/////Account.h

#pragma once
#include <string>
#include <fstream>
#include <iostream>
using namespace std;
class Account
{
public:

    Account(string login, string password, int access_level, bool is_approved);
    Account(){};
    string login;//логин
    string hashed_password;//хешированный пароль
    string salt;//соль для пароля
    int access_level=1;//уровень доступа
    bool is_approved= false;//подтвержденность

    friend std::istream &operator >> (std::istream &is, Account &f);
    friend std::ostream& operator <<(std::ostream &os, Account& f);
};

/////Account.cpp

#include <iomanip>
#include "Account.h"
#include "Hash/Hash.h"

using namespace std;

Account::Account(string login, string password, int access_level, bool is_approved)
{
    string salt;
    this->access_level = access_level;
    this->hashed_password = hashString(password, salt);
    this->login = login;
    this->is_approved = is_approved;
    this->salt = salt;
}

std::istream &operator>>(istream &is, Account &f) {
    string login, password;
    if(typeid(is) == typeid(ifstream))
    {
        string hashed_password, salt;
        bool is_approved;
        int access_level;
        is >> login;
        is >> hashed_password;
        is >> salt;
        is >> access_level;
        is >> is_approved;
        f.login = login;
        f.hashed_password = hashed_password;
        f.salt = salt;
        f.access_level = access_level;
        f.is_approved = is_approved;
    }
    else
    {

        cout<<"Enter login: ";
        is >> login;
        cout<<"Enter password: ";
        is >> password;
        string salt;
        f.login = login;
        f.hashed_password = hashString(password, salt);
        f.salt = salt;
    }
    return is;
}

std::ostream &operator << (ostream &os, Account &f) {
    if(typeid(os) == typeid(ofstream))
    {
        os << endl;
        os << f.login <<' ';
        os << f.hashed_password <<' ';
        os << f.salt <<' ';
        os << f.access_level << ' ';
        os << f.is_approved;

    }
    return os;
}


/////Core.h

#pragma once
#include "DB_accounts.h"
#include "MySpace.h"

void mainFunc();//главная функция, вызываемая в main
void signIn(string login, string password);//вход
string inputPassword();//ввод пароля
Account* signUp();//регистрация
string inputNumber(string s = "");//ввод номера группы
string inputName(string s = "");//ввод фио студента
void *inputCredits(bool *arr);//ввод результатов зачетов
bool inputBool();//ввод результата зачета
void *inputExams(int *arr);//ввод результатов экзаменов

/////Core.cpp

#include <string>
#include <conio.h>
#include "Core.h"
#include "Menues.h"
#include "globals.h"
#include "Hash/Hash.h"

using namespace std;
void mainFunc()
{
    system("");
    globals::db_accounts.update();
    globals::db_students.update();
    while(true)
    {
        if (mainMenu())
            return;
        system("cls");
    }
}

string inputPassword()
{
    string password;
    while(true)
    {
        char c = getch();
        if(c == 13) // Enter
        {
            if(password.length()!=0)
                break;
        }
        else if(c == 8) // Backspace
        {
            if(password.length()!=0)
            {
                cout << "\b \b";
                password.pop_back();
            }
        }
        else if(c != 32)
        {
            password+=c;
            cout<<'*';
        }
    }
    cout<<endl;
    return password;
}

void signIn(string login, string password)
{
    //globals::db_accounts.update();
    int idx = globals::db_accounts.findByLogin(login);
    Account & acc = globals::db_accounts.accounts[idx];
    if(idx == -1 || acc.hashed_password != hashString(password, acc.salt))
    {
        cout << "Incorrect login or password\n";
        system("pause");
        return;
    }
    else
    {
        if(!acc.is_approved)
        {
            cout << "Account doesn't approved by administrator\n";
            system("pause");
            return;
        }
        if(acc.access_level == 0)
        {
            userMenuAdmin();
        }
        else
        {
            userMenuUser();
        }
    }
}

Account *signUp()
{
    string password, login;
    cout<<"Enter login: ";
    if(cin.peek()=='\n')
        cin.get();
    getline(cin, login);
    if(login.find(' ') != -1)
    {
        cout << "Login can't contain spaces\n";
        system("pause");
        return nullptr;
    }
    if(globals::db_accounts.findByLogin(login)!=-1)
    {
        cout<<"Login already exist\n";
        system("pause");
        return nullptr;
    }

    while(true)
    {
        cout << "Enter password: \n";
        cout << "Confirm password: ";
        UP_LINE();
        TO_COLUMN(17);
        password = inputPassword();
        TO_COLUMN(19);
        if (password == inputPassword())
        {
            break;
        }
        cout << "Passwords are different\n";
        system("pause");
        UP_LINES(4);
        CLEAR_TO_END();
    }

    Account* acc = new Account(login, password, 1, false);
    return acc;

}

string inputNumber(string s)
{
    cout << s;
    while(true)
    {

        char c = getch();

        if (c == 13) // Enter
        {
            if (s.length() == 6)
                break;
        }
        else if (c == 8) // Backspace
        {
            if (s.length() != 0)
            {
                cout << "\b \b";
                s.pop_back();
            }
        }
        else if (isdigit(c) && s.length() <= 5)
        {
            s += c;
            cout << c;
        }
    }
    cout<<endl;
    return s;
}

string inputName(string s)
{
    cout << s;
    while(true)
    {
        char c = getch();
        if(c == 13) // Enter
        {
            if(s.length()>=6)
                break;
        }
        else if(c == 8) // Backspace
        {
            if(s.length()!=0)
            {
                cout << "\b \b";
                s.pop_back();
            }
        }
        else if(isalpha(c) || (s.length() != 0 && s[s.length()-1] != ' ' && c == ' '))
        {
            s+=c;
            cout << c;
        }
    }
    cout<<endl;
    return s;
}

bool inputBool()
{
    while(true)
    {
        char c = getch();
        if (c == 'y')
        {
            cout << 'y';
            return true;
        }
        else if (c == 'n') // Backspace
        {
            cout << 'n';
            return false;
        }
    }
}

void *inputCredits(bool *arr)
{
    cout << "INAD passed [y/n]: ";
    arr[0] = inputBool();
    cout << "\nIKG passed [y/n]: ";
    arr[1] = inputBool();
    cout << "\nLANG passed [y/n]: ";
    arr[2] = inputBool();
    cout << "\nHIST passed [y/n]: ";
    arr[3] = inputBool();
    cout << "\nPOLIT passed [y/n]: ";
    arr[4] = inputBool();
    cout << endl;
    return arr;
}

void *inputExams(int *arr)
{
    cout << "Input MATH mark:\n";
    input(arr[0], 0, 10);
    cout << "Input OOP mark:\n";
    input(arr[1], 0, 10);
    cout << "Input TRPO mark: \n";
    input(arr[2], 0, 10);
    cout << "Input PHYS mark:\n";
    input(arr[3], 0, 10);
    cout << "Input OAIP mark:\n";
    input(arr[4], 0, 10);
    cout << endl;
    return arr;
}

/////DB_accounts.h

#pragma once
#include <fstream>
#include <vector>
#include "Account.h"

using namespace std;
class DB_accounts //класс для работы с аккаунтами
{
public:
    DB_accounts(string file);
    string file;
    ifstream fin;
    ofstream fout;
    vector<Account> accounts;
    void update();//обновить массив
    void save();//сохранить в файл
    void add(Account& acc);//добавить в массив
    int findByLogin(string login);//поиск в массиве по логину
    void deleteAccount(int idx);//удалить аккаунт
    void approveAccount(int idx);//подтвердить аккаунт
    int getAmountOfNotApproved();//получить количество не подтвержденных аккаунтов
};

/////DB_accounts.cpp

#include <string>
#include "DB_accounts.h"
#include "MySpace.h"

using namespace std;

DB_accounts::DB_accounts(string file) {
    this->file = file;
}
Account& createMainAdmin()
{
    Account *acc = new Account("admin", "admin", 0, true);
    return *acc;
}

void DB_accounts::update() {
    accounts.clear();
    fout.close();
    fin.open(file);
    if(!fin.is_open())
    {
        fout.open(file);
        fout.close();
    }
    if(isFileEmpty(fin))
    {
        fin.close();
        this->add(createMainAdmin());
        fin.open(file);
    }
    while(!fin.eof())
    {
        Account acc;
        fin>>acc;
        accounts.push_back(acc);
    }
    fin.close();
}

void DB_accounts::add(Account &acc) {
    accounts.push_back(acc);
    save();
}

void DB_accounts::save() {
    fin.close();
    fout.open(file);
    for(Account acc : accounts)
        fout<<acc;
    fout.close();
    //update();
}

int DB_accounts::findByLogin(string login) {
    for(int i = 0; i < accounts.size(); i++)
    {
        if(accounts[i].login == login)
        {
            return i;
        }
    }
    return -1;
}

void DB_accounts::deleteAccount(int idx)
{
    accounts.erase(accounts.begin() + idx);
    save();
}

int DB_accounts::getAmountOfNotApproved()
{
    int sum = 0;
    for(auto& acc : accounts)
    {
        if(!acc.is_approved)
            sum++;
    }
    return sum;
}

void DB_accounts::approveAccount(int idx)
{
    accounts.at(idx).is_approved = true;
    save();
}

/////DB_students.h

#pragma once
#include <fstream>
#include <vector>
#include "Student.h"
using namespace std;
class DB_students//класс для работы со студентами
{
public:
    DB_students(string file);
    string file;
    ifstream fin;
    ofstream fout;
    vector<Student> students;
    void update();//обновить массив
    void save();//сохранить в файл
    void add(Student& acc);//добавить в массив
    void deleteStudent(int idx);//удалить студента
};

/////DB_students.cpp

#include "DB_students.h"
#include "MySpace.h"

using namespace std;
DB_students::DB_students(string file) {
    this->file = file;
}

void DB_students::update() {
    students.clear();
    fout.close();
    fin.open(file);
    if(!fin.is_open())
    {
        fout.open(file);
        fout.close();
    }

    if(!isFileEmpty(fin))
    {
        while (!fin.eof())
        {
            Student stud;
            fin >> stud;
            students.push_back(stud);
        }
        fin.close();
    }
}

void DB_students::add(Student &stud) {
    students.push_back(stud);
    save();
}

void DB_students::save() {
    fin.close();
    fout.open(file);
    for(Student acc : students)
        fout<<acc;
    fout.close();
}

void DB_students::deleteStudent(int idx)
{
    students.erase(students.begin() + idx);
    save();
}

/////globals.h

#pragma once

#include <string>
#include "DB_accounts.h"
#include "DB_students.h"

namespace globals {

    extern std::string filenameAccounts;//имя файла аккаунтов
    extern std::string filenameStudents;//имя файла студентов
    extern DB_accounts db_accounts;//объект класса работы с аккаунтами
    extern DB_students db_students;//объект класса работы со студентами
}

/////globals.cpp

#include "globals.h"
#include <string>
#include "DB_accounts.h"

namespace globals
{
    std::string filenameAccounts = "accounts.txt";
    std::string filenameStudents = "students.txt";
    DB_accounts db_accounts(filenameAccounts);
    DB_students db_students(filenameStudents);
}

/////Hash.h

#pragma once
#include <string>
using namespace std;
string hashString(string s, string &out_salt);

/////Hash.cpp

#include "Hash.h"
#include <iostream>
#include <cstdlib>
#include <ctime>
#include <string>
#include "sha256.h"

using namespace std;

const int SALT_SIZE = 16; // длина соли
const int SYMBOLS_SIZE = 62; // набор символов, из которых генерируется соль

string generateSalt(int salt_size); // функция генерации соли

string getSymbolsForSalt(); // функция формирования набора символов
// вида: aA0bB1cC2dD3eE4fF5gG6hH7iI8jJ9kKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ

string generateSalt(int salt_size)
{
    string symbols = getSymbolsForSalt();

    srand(time(NULL));

    string salt;
    salt.reserve(salt_size);

    for (int i = 0; i < salt_size; i++)
    {
        salt.push_back(symbols[rand() % SYMBOLS_SIZE]);
    }

    return salt;
}


string getSymbolsForSalt()
{
    string symbols;
    symbols.reserve(SYMBOLS_SIZE);

    char little_letter = 'a';
    char big_letter = 'A';
    char number = '0';
    int i = 0;
    for (int k = 0; k < 26; k++)
    {
        symbols.push_back(little_letter++);
        symbols.push_back(big_letter++);
        if (k < 10) symbols.push_back(number++);
    }

    return symbols;
}


string hashString(string s, string &out_salt) {
    if(out_salt=="")
        out_salt = generateSalt(SALT_SIZE);
    return sha256(s + out_salt);
}


/////sha256.h

#pragma once
#pragma once

#ifndef SHA256_H
#define SHA256_H
#include <string>

class SHA256
{
protected:
    typedef unsigned char uint8;
    typedef unsigned int uint32;
    typedef unsigned long long uint64;

    const static uint32 sha256_k[];
    static const unsigned int SHA224_256_BLOCK_SIZE = (512 / 8);
public:
    void init();
    void update(const unsigned char* message, unsigned int len);
    void final(unsigned char* digest);
    static const unsigned int DIGEST_SIZE = (256 / 8);

protected:
    void transform(const unsigned char* message, unsigned int block_nb);
    unsigned int m_tot_len;
    unsigned int m_len;
    unsigned char m_block[2 * SHA224_256_BLOCK_SIZE];
    uint32 m_h[8];
};

std::string sha256(std::string input);

#define SHA2_SHFR(x, n)    (x >> n)
#define SHA2_ROTR(x, n)   ((x >> n) | (x << ((sizeof(x) << 3) - n)))
#define SHA2_ROTL(x, n)   ((x << n) | (x >> ((sizeof(x) << 3) - n)))
#define SHA2_CH(x, y, z)  ((x & y) ^ (~x & z))
#define SHA2_MAJ(x, y, z) ((x & y) ^ (x & z) ^ (y & z))
#define SHA256_F1(x) (SHA2_ROTR(x,  2) ^ SHA2_ROTR(x, 13) ^ SHA2_ROTR(x, 22))
#define SHA256_F2(x) (SHA2_ROTR(x,  6) ^ SHA2_ROTR(x, 11) ^ SHA2_ROTR(x, 25))
#define SHA256_F3(x) (SHA2_ROTR(x,  7) ^ SHA2_ROTR(x, 18) ^ SHA2_SHFR(x,  3))
#define SHA256_F4(x) (SHA2_ROTR(x, 17) ^ SHA2_ROTR(x, 19) ^ SHA2_SHFR(x, 10))
#define SHA2_UNPACK32(x, str)                 \
{                                             \
    *((str) + 3) = (uint8) ((x)      );       \
    *((str) + 2) = (uint8) ((x) >>  8);       \
    *((str) + 1) = (uint8) ((x) >> 16);       \
    *((str) + 0) = (uint8) ((x) >> 24);       \
}
#define SHA2_PACK32(str, x)                   \
{                                             \
    *(x) =   ((uint32) *((str) + 3)      )    \
           | ((uint32) *((str) + 2) <<  8)    \
           | ((uint32) *((str) + 1) << 16)    \
           | ((uint32) *((str) + 0) << 24);   \
}
#endif


/////sha256.cpp

#define _CRT_SECURE_NO_WARNINGS

#include <cstring>
#include <fstream>
#include "sha256.h"


const unsigned int SHA256::sha256_k[64] = //UL = uint32
        { 0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
          0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
          0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
          0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
          0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
          0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
          0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
          0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
          0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
          0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
          0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
          0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
          0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
          0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
          0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
          0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2 };

void SHA256::transform(const unsigned char* message, unsigned int block_nb)
{
    uint32 w[64];
    uint32 wv[8];
    uint32 t1, t2;
    const unsigned char* sub_block;
    int i;
    int j;
    for (i = 0; i < (int)block_nb; i++) {
        sub_block = message + (i << 6);
        for (j = 0; j < 16; j++) {
            SHA2_PACK32(&sub_block[j << 2], &w[j]);
        }
        for (j = 16; j < 64; j++) {
            w[j] = SHA256_F4(w[j - 2]) + w[j - 7] + SHA256_F3(w[j - 15]) + w[j - 16];
        }
        for (j = 0; j < 8; j++) {
            wv[j] = m_h[j];
        }
        for (j = 0; j < 64; j++) {
            t1 = wv[7] + SHA256_F2(wv[4]) + SHA2_CH(wv[4], wv[5], wv[6])
                 + sha256_k[j] + w[j];
            t2 = SHA256_F1(wv[0]) + SHA2_MAJ(wv[0], wv[1], wv[2]);
            wv[7] = wv[6];
            wv[6] = wv[5];
            wv[5] = wv[4];
            wv[4] = wv[3] + t1;
            wv[3] = wv[2];
            wv[2] = wv[1];
            wv[1] = wv[0];
            wv[0] = t1 + t2;
        }
        for (j = 0; j < 8; j++) {
            m_h[j] += wv[j];
        }
    }
}

void SHA256::init()
{
    m_h[0] = 0x6a09e667;
    m_h[1] = 0xbb67ae85;
    m_h[2] = 0x3c6ef372;
    m_h[3] = 0xa54ff53a;
    m_h[4] = 0x510e527f;
    m_h[5] = 0x9b05688c;
    m_h[6] = 0x1f83d9ab;
    m_h[7] = 0x5be0cd19;
    m_len = 0;
    m_tot_len = 0;
}

void SHA256::update(const unsigned char* message, unsigned int len)
{
    unsigned int block_nb;
    unsigned int new_len, rem_len, tmp_len;
    const unsigned char* shifted_message;
    tmp_len = SHA224_256_BLOCK_SIZE - m_len;
    rem_len = len < tmp_len ? len : tmp_len;
    memcpy(&m_block[m_len], message, rem_len);
    if (m_len + len < SHA224_256_BLOCK_SIZE) {
        m_len += len;
        return;
    }
    new_len = len - rem_len;
    block_nb = new_len / SHA224_256_BLOCK_SIZE;
    shifted_message = message + rem_len;
    transform(m_block, 1);
    transform(shifted_message, block_nb);
    rem_len = new_len % SHA224_256_BLOCK_SIZE;
    memcpy(m_block, &shifted_message[block_nb << 6], rem_len);
    m_len = rem_len;
    m_tot_len += (block_nb + 1) << 6;
}

void SHA256::final(unsigned char* digest)
{
    unsigned int block_nb;
    unsigned int pm_len;
    unsigned int len_b;
    int i;
    block_nb = (1 + ((SHA224_256_BLOCK_SIZE - 9)
                     < (m_len % SHA224_256_BLOCK_SIZE)));
    len_b = (m_tot_len + m_len) << 3;
    pm_len = block_nb << 6;
    memset(m_block + m_len, 0, pm_len - m_len);
    m_block[m_len] = 0x80;
    SHA2_UNPACK32(len_b, m_block + pm_len - 4);
    transform(m_block, block_nb);
    for (i = 0; i < 8; i++) {
        SHA2_UNPACK32(m_h[i], &digest[i << 2]);
    }
}

std::string sha256(std::string input)
{
    unsigned char digest[SHA256::DIGEST_SIZE];
    memset(digest, 0, SHA256::DIGEST_SIZE);

    SHA256 ctx = SHA256();
    ctx.init();
    ctx.update((unsigned char*)input.c_str(), input.length());
    ctx.final(digest);

    char buf[2 * SHA256::DIGEST_SIZE + 1];
    buf[2 * SHA256::DIGEST_SIZE] = 0;
    for (int i = 0; i < SHA256::DIGEST_SIZE; i++)
        sprintf(buf + i * 2, "%02x", digest[i]);
    return std::string(buf);
}

/////main.h

#pragma once
#include <iostream>
#include "Core.h"

/////main.cpp

#include "main.h"
using namespace std;
int main() {
    mainFunc();
    system("pause");
}

/////Menues.h

#pragma once
#include <vector>
#include "Core.h"
#include "Student.h"
#include "globals.h"

bool mainMenu(); //главное меню

bool chooseOption(std::vector<void(*)()> args);//вспомогательная функция, обрабатывающая выбор, сделанный пользователем
/// функции, заканчивающиеся на _select, вызываются при выборе их пользователем
void signIn_select();//вход
void signUp_select();//регистрация
void userMenuAdmin();//меню админа
void userMenuUser();//меню пользователя
namespace accounts //пространство имен аккаунтов
{
    void show_select();//выбор показать
    void add_select();//выбор добавить
    void edit_select();//выбор изменить
    void delete_select();//выбор удалить
    void approveRequests_select();//выбор подтвердить запросы
    void rejectRequest();//отклонить запрос
    void approveRequest();//подтвердить запрос
    void show();//показать
    void showTop();//показать шапку
}
namespace students//пространство имен студентов
{
    void show_select();//выбор показать
    void add_select();//выбор добавить
    void edit_select();//выбор изменить
    void delete_select();//выбор удалить
    void show(vector<Student> &students = globals::db_students.students);//показать
    void showTop();//показать шапку
    void sort_select();//выбор сортировка
    void individualTask_select();//выбор индивидуальное задание
    void search_select();//выбор поиск
}
namespace width //заданные значение ширины столбцов таблиц
{
    extern int id, login, hashed_password, access;
    extern int name, number, credits[5], exams[5], debts, average_mark;
    extern int sumStud(), sumCredits(), sumExams();

}

/////Menues.cpp

#include <iostream>
#include <conio.h>
#include <string>
#include <iomanip>
#include <algorithm>
#include "Menues.h"
#include "MySpace.h"
#include "Account.h"
#include "globals.h"
#include "Hash/Hash.h"

using namespace std;
namespace width
{
    int id = 6, login = 15, hashed_password = 64, access = 7;
    int name = 34, number = 8, debts = 7, average_mark = 5;
    //! INAD:IKG:LANG:HIST:POLIT ,  MATH:OOP:TRPO:PHYS:OAIP
    int credits[5] = {5, 3, 4, 4, 6};
    int exams[5] = {5, 3, 4, 4, 5};
    int sumStud()
    {
        int sum = 0;
        sum += name + number;
        sum += sumCredits();
        sum += sumExams();
        sum += average_mark;
        sum += debts;
        sum += id;
        return sum;
    }
    int sumCredits()
    {
        int sum=0;
        for(int i : credits)
        {
            sum += i;
        }
        return sum + 4;
    }
    int sumExams()
    {
        int sum=0;
        for(int i : exams)
        {
            sum += i;
        }
        return sum + 4;
    }
}


bool chooseOption(vector<void (*)()> args) {
    int choice;
    while (true)
    {
        choice = getch();
        choice-='0';
        if (choice == 0)
            return true;
        if (choice <= args.size() && choice > 0)
        {
            break;
        }

    }
    args[choice-1]();
    return false;

}

bool mainMenu() {

    std::cout<<"Main menu:\n"
               "1 - Sign in\n"
               "2 - Sign up\n"
               "0 - EXIT\n";
    bool b = chooseOption({signIn_select, signUp_select});
    return b;
}

void signIn_select() {
    string login;
    string password;
    system("cls");
    std::cout<<"signIn\n";
    cout<< "login: ";
    if(cin.peek() == '\n')
        cin.get();
    getline(cin, login);
    cout << "password: ";
    password = inputPassword();
    signIn(login, password);
}

void signUp_select() {
    system("cls");
    std::cout<<"signUp\n";

    Account *acc = signUp();
    if(acc == nullptr)
        return;
    globals::db_accounts.add(*acc);
    cout<<"Done!\n";
    system("pause");
}

void userMenuAdmin()
{
    while(true)
    {
        system("cls");
        cout<<"-----DB <Accounts>-----\n";
        cout<<"1 - Show\n2 - Add\n3 - Edit\n4 - Delete\n5 - Approve requests\n\n";
        cout<<"-----DB <Students>-----\n";
        cout<<"6 - Show\n7 - Add\n8 - Edit\n9 - Delete\n0 - Back\n";
        if(chooseOption({accounts::show_select, accounts::add_select, accounts::edit_select, accounts::delete_select, accounts::approveRequests_select,
                         students::show_select, students::add_select, students::edit_select, students::delete_select}))
            return;
    }

}

void userMenuUser()
{
    system("cls");
    students::show_select();

}

#pragma region accounts
void accounts::show_select()
{
    system("cls");

    accounts::show();

    system("pause");

}

void accounts::approveRequests_select()
{
    while(true)
    {
        system("cls");
        if(globals::db_accounts.getAmountOfNotApproved() == 0)
        {
            cout << "There are no " << YELLOW << "unapproved" << DEFAULT_COLOR << " accounts" <<endl;
            system("pause");
            return;
        }

        cout.fill('=');
        cout << setw(width::id + width::login + width::hashed_password + width::access + 5) << '=' << endl;
        cout.fill(' ');

        cout << '|' << setw(width::id) << centerString("ID", width::id, ' ') << setw(1) << "|";
        cout << setw(width::login) << centerString("Login", width::login, ' ') << setw(1) << '|';
        cout << setw(width::hashed_password) << centerString("Hashed password", width::hashed_password, ' ') << setw(1) << '|';
        cout << setw(width::access) << centerString("Access", width::access, ' ') << setw(1) << '|' << endl;

        cout.fill('=');
        cout << setw(width::id + width::login + width::hashed_password + width::access + 5) << '=' << endl;
        cout.fill(' ');

        for(int id = 1; id <= globals::db_accounts.accounts.size();id++)
        {
            Account& acc = globals::db_accounts.accounts[id-1];
            if(!acc.is_approved)
            {
                cout << '|';
                cout << setw(width::id) << centerString(id < 10 ? ("0" + to_string(id)) : to_string(id), width::id, ' ')
                     << setw(1) << '|';
                cout << setw(width::login) << left << acc.login << setw(1) << '|';
                cout << setw(width::hashed_password) << left << acc.hashed_password << setw(1) << '|';
                cout << setw(width::access) << centerString(acc.access_level == 0 ? "Admin" : "User", width::access, ' ')
                     << setw(1) << '|' << endl;

                cout.fill('-');
                cout << setw(width::id + width::login + width::hashed_password + width::access + 5) << '-' << endl;
                cout.fill(' ');
            }

        }

        cout<<"1 - Reject\n2 - Approve\n0 - Back\n";
        if(chooseOption({accounts::rejectRequest, accounts::approveRequest}))
            return;
    }

}

void accounts::add_select()
{
    system("cls");
    Account *acc = signUp();
    if(acc == nullptr)
        return;
    int access_level;
    cout<<"Input access level of new account:\n0 - Admin\n1 - User\n";

    input(access_level, 0, 1);
    acc->access_level = access_level;
    acc->is_approved = true;
    globals::db_accounts.add(*acc);
    cout<<"Done!\n";
    system("pause");
}

void accounts::edit_select()
{
    while(true)
    {
        system("cls");
        if (globals::db_accounts.accounts.size() == 1)
        {
            cout << "There is only one " << GREEN << "Main Admin" << DEFAULT_COLOR << endl;
            system("pause");
            return;
        }

        accounts::show();
        int idx;
        cout << "Choose account to " << CYAN << "edit" << DEFAULT_COLOR << endl;
        cout << "0 - BACK\n";
        input(idx, 2, globals::db_accounts.accounts.size(), {0});
        if (idx == 0)
            return;
        while (true)
        {
            system("cls");
            accounts::showTop();

            Account &acc = globals::db_accounts.accounts[idx - 1];
            cout << '|';
            cout << setw(width::id) << centerString(idx < 10 ? ("0" + to_string(idx)) : to_string(idx), width::id, ' ')
                 << setw(1) << '|';
            cout << setw(width::login) << left << acc.login << setw(1) << '|';
            cout << setw(width::hashed_password) << left << acc.hashed_password << setw(1) << '|';
            cout << setw(width::access) << centerString(acc.access_level == 0 ? "Admin" : "User", width::access, ' ')
                 << setw(1) << '|' << endl;

            cout.fill('=');
            cout << setw(width::id + width::login + width::hashed_password + width::access + 5) << '=' << endl;
            cout.fill(' ');


            int choice;
            cout << "Choose field to " << CYAN << "edit" << DEFAULT_COLOR << endl;
            cout << "1 - Login\n2 - Password\n3 - Access level\n0 - Back\n";
            bool is_back = false;
            while (true)
            {
                choice = getch();
                choice -= '0';
                if (choice == 0)
                {
                    is_back = true;
                    break;

                }
                if (choice <= 3 && choice > 0)
                {
                    break;
                }

            }

            if (is_back)
                break;

            UP_LINES(5);
            CLEAR_TO_END();

            switch (choice)
            {
                case 1:
                {
                    string login;
                    cout << "New login: ";
                    if (cin.peek() == '\n')
                        cin.get();
                    getline(cin, login);
                    if (login.find(' ') != -1)
                    {
                        cout << "Login can't contain spaces\n";
                        system("pause");
                        break;
                    }
                    if (globals::db_accounts.findByLogin(login) != -1)
                    {
                        cout << "Login already exist\n";
                        system("pause");
                        break;
                    }
                    acc.login = login;
                    cout << "Done!\n";
                    break;
                }
                case 2:
                {
                    string password;
                    while (true)
                    {
                        cout << "New password: \n";
                        cout << "Confirm password: ";
                        UP_LINE();
                        TO_COLUMN(15);
                        password = inputPassword();
                        TO_COLUMN(19);
                        if (password == inputPassword())
                        {
                            break;
                        }
                        cout << "Passwords are different\n";
                        system("pause");
                        UP_LINES(4);
                        CLEAR_TO_END();
                    }
                    string salt;
                    acc.hashed_password = hashString(password, salt);
                    acc.salt = salt;
                    cout << "Done!\n";
                    break;
                }
                case 3:
                {
                    int access_level;
                    cout << "New access level of account:\n0 - Admin\n1 - User\n";

                    input(access_level, 0, 1);
                    acc.access_level = access_level;
                    cout << "Done!\n";
                    break;
                }
            }
            globals::db_accounts.save();
        }
    }
}

void accounts::delete_select()
{
    while(true)
    {
        system("cls");
        if (globals::db_accounts.accounts.size() == 1)
        {
            cout << "There is only one " << GREEN << "Main Admin" << DEFAULT_COLOR << endl;
            return;
        }

        accounts::show();

        int idx;
        cout << "Choose account to " << RED << "DELETE" << DEFAULT_COLOR << endl;
        cout << "0 - BACK\n";
        input(idx, 2, globals::db_accounts.accounts.size(), {0});
        if (idx == 0)
            return;
        cout << "Do you really want to " << RED << "DELETE " << DEFAULT_COLOR << globals::db_accounts.accounts[idx - 1].login << " [y/n]\n";
        bool b;
        input(b);
        if (b)
            globals::db_accounts.deleteAccount(idx - 1);
        cout << "Done!\n";
        system("pause");
    }
}

void accounts::rejectRequest()
{
    UP_LINES(3);
    CLEAR_TO_END();
    cout << "Choose account to " << PINK << "reject" << DEFAULT_COLOR <<endl;
    int c;
    while(true)
    {
        input(c);
        if ((c < 1 || c > globals::db_accounts.accounts.size()) || globals::db_accounts.accounts[c-1].is_approved)
        {
            cout << "Incorrect input" << "\a\n";
            sleep(1);
            UP_LINES(2);
            CLEAR_TO_END();
        }
        else
        {
            cout << "Do you really want to " << PINK << "REJECT" << DEFAULT_COLOR << " this request and " << RED << "DELETE"<< DEFAULT_COLOR << " this account? [y/n]\n";
            bool b;
            input (b);
            if(!b)
                return;
            globals::db_accounts.deleteAccount(c - 1);
            cout<<"Done!\n";
            system("pause");
            break;
        }
    }
}

void accounts::approveRequest()
{
    UP_LINES(3);
    CLEAR_TO_END();
    cout << "Choose accounts to " << GREEN << "approve" << DEFAULT_COLOR <<endl;
    int c;
    while(true)
    {
        input(c);
        if ((c < 1 || c > globals::db_accounts.accounts.size()) || globals::db_accounts.accounts[c-1].is_approved)
        {
            cout << "Incorrect input" << "\a\n";
            sleep(1);
            UP_LINES(2);
            CLEAR_TO_END();
        }
        else
        {
            cout << "Do you really want to " << GREEN << "Approve" << DEFAULT_COLOR << " this account? [y/n]\n";
            bool b;
            input (b);
            if(!b)
                return;
            globals::db_accounts.approveAccount(c - 1);
            cout<<"Done!\n";
            system("pause");
            break;
        }
    }
}

void accounts::show()
{
    accounts::showTop();

    for(int id = 2; id <= globals::db_accounts.accounts.size();id++)
    {
        Account& acc = globals::db_accounts.accounts[id-1];
        if(!acc.is_approved)
            cout << YELLOW;
        cout << '|';
        cout <<setw(width::id) << centerString(id < 10 ? ("0" + to_string(id)) : to_string(id), width::id, ' ')
             << setw(1) << '|';
        cout << setw(width::login) << left << acc.login << setw(1) << '|';
        cout << setw(width::hashed_password) << left << acc.hashed_password << setw(1) << '|';
        cout << setw(width::access) << centerString(acc.access_level == 0 ? "Admin" : "User", width::access, ' ')
             << setw(1) << '|' << endl;
        cout<<DEFAULT_COLOR;
        cout.fill('-');
        cout << setw(width::id + width::login + width::hashed_password + width::access + 5) << '-' << endl;
        cout.fill(' ');

    }
    cout<< YELLOW <<"Yellow" << DEFAULT_COLOR << " accounts are not approved\n";
}

void accounts::showTop()
{
    cout.fill('=');
    cout << setw(width::id + width::login + width::hashed_password + width::access + 5) << '=' << endl;
    cout.fill(' ');

    cout << '|' << setw(width::id) << centerString("ID", width::id, ' ') << setw(1) << "|";
    cout << setw(width::login) << centerString("Login", width::login, ' ') << setw(1) << '|';
    cout << setw(width::hashed_password) << centerString("Hashed password", width::hashed_password, ' ') << setw(1) << '|';
    cout << setw(width::access) << centerString("Access", width::access, ' ') << setw(1) << '|' << endl;

    cout.fill('=');
    cout << setw(width::id + width::login + width::hashed_password + width::access + 5) << '=' << endl;
    cout.fill(' ');
}

#pragma endregion

#pragma region students

void students::show_select()
{
    while(true)
    {
        system("cls");
        if(globals::db_students.students.size()==0)
        {
            cout << "Students database is empty\n";
            system("pause");
            return;
        }
        show();
        cout << "1 - Sort\n2 - Search\n3 - Individual task\n0 - Back\n";

        if(chooseOption({students::sort_select, students::search_select, students::individualTask_select}))
            return;
    }
}

void students::add_select()
{
    system("cls");
    string name, number;
    bool credits[5];
    int exams[5];
    cout << "Input name: ";
    name = inputName();

    cout << "Input number: ";
    number = inputNumber();

    cout << "Input credits:\n";
    inputCredits(credits);

    cout << "Input exams:\n";
    inputExams(exams);

    Student stud(name, number, credits, exams);

    globals::db_students.add(stud);
    cout << "Done!\n";
    system("pause");
}

void students::edit_select()
{
    while(true)
    {
        system("cls");

        if (globals::db_students.students.size() == 1)
        {
            cout << "There is no students" << endl;
            system("pause");
            return;
        }

        int idx;
        show();
        cout << "Choose Student to " << CYAN << "edit" << DEFAULT_COLOR << endl;
        cout << "0 - BACK\n";
        input(idx, 1, globals::db_students.students.size(), {0});
        if (idx == 0)
            return;

        while (true)
        {
            system("cls");
            showTop();

            Student &stud = globals::db_students.students[idx - 1];

            cout << '|' << setw(width::id)
                 << centerString(idx < 10 ? ("0" + to_string(idx)) : to_string(idx), width::id, ' ')
                 << setw(1) << '|';
            cout << setw(width::name) << left << stud.name << setw(1) << '|';
            cout << setw(width::number) << centerString(stud.number, width::number, ' ') << setw(1) << '|';
            cout << right;
            for (int i = 0; i < 5; i++)
            {
                bool b = stud.credits[i];
                int curr_w = width::credits[i];
                if (i == 4)
                    curr_w--;
                if (b)
                {
                    cout << GREEN;
                    cout << setw(curr_w) << 'P';
                }
                else
                {

                    cout << RED;
                    cout << setw(curr_w) << 'F';
                }
                if (i != 4)
                    cout << ' ';
                cout << DEFAULT_COLOR;
            }
            cout << " |";
            cout << DEFAULT_COLOR;
            for (int i = 0; i < 5; i++)
            {
                int x = stud.exams[i];
                int curr_w = width::exams[i];
                if (i == 4)
                    curr_w--;

                if (x > 4)
                {
                    cout << GREEN;
                }
                else if (x == 4)
                {
                    cout << YELLOW;
                }
                else
                {
                    cout << RED;
                }

                cout << setw(curr_w) << x;

                if (i != 4)
                    cout << ' ';
                cout << DEFAULT_COLOR;
            }
            cout << " |";
            cout << fixed << setw(width::average_mark) << setprecision(1) << stud.average_mark << setw(1) << "|";
            if (stud.debts == 0)
                cout << GREEN;
            cout << setw(width::debts) << stud.debts;
            cout << WHITE << '|';
            cout << DEFAULT_COLOR;
            cout << endl;

            cout.fill('=');
            cout << setw(width::sumStud() + 8) << '=' << endl;
            cout.fill(' ');

            int choice;
            cout << "Choose field to " << CYAN << "edit" << DEFAULT_COLOR << endl;
            cout << "1 - Name\n2 - Group\n3 - Credits\n4 - Exams\n0 - Back\n";
            bool is_back = false;
            while (true)
            {
                choice = getch();
                choice -= '0';
                if (choice == 0)
                {
                    is_back = true;
                    break;
                }
                if (choice <= 4 && choice > 0)
                {
                    break;
                }

            }

            if (is_back)
                break;

            UP_LINES(6);
            CLEAR_TO_END();


            switch (choice)
            {
                case 1:
                {
                    cout << "New name: ";
                    stud.name = inputName(stud.name);

                    break;
                }
                case 2:
                {
                    cout << "New group: ";
                    stud.number = inputNumber(stud.number);
                    break;
                }
                case 3:
                {
                    cout << "INAD passed  (old " << YELLOW << (stud.credits[0] ? 'y' : 'n') << DEFAULT_COLOR << ") [y/n] : ";
                    stud.credits[0] = inputBool();
                    cout << "\nIKG passed   (old " << YELLOW << (stud.credits[1] ? 'y' : 'n') << DEFAULT_COLOR << ") [y/n]: ";
                    stud.credits[1] = inputBool();
                    cout << "\nLANG passed  (old " << YELLOW << (stud.credits[2] ? 'y' : 'n') << DEFAULT_COLOR << ") [y/n]: ";
                    stud.credits[2] = inputBool();
                    cout << "\nHIST passed  (old " << YELLOW << (stud.credits[3] ? 'y' : 'n') << DEFAULT_COLOR << ") [y/n]: ";
                    stud.credits[3] = inputBool();
                    cout << "\nPOLIT passed (old " << YELLOW << (stud.credits[4] ? 'y' : 'n') << DEFAULT_COLOR << ") [y/n]: ";
                    stud.credits[4] = inputBool();
                    stud.update();
                    break;
                }
                case 4:
                {
                    cout << "Input MATH mark (old " << YELLOW << stud.exams[0] << DEFAULT_COLOR << "):\n";
                    input(stud.exams[0], 0, 10);

                    cout << "Input OOP mark  (old " << YELLOW << stud.exams[1] << DEFAULT_COLOR << "):\n";
                    input(stud.exams[1], 0, 10);

                    cout << "Input TRPO mark (old " << YELLOW << stud.exams[2] << DEFAULT_COLOR << "): \n";
                    input(stud.exams[2], 0, 10);

                    cout << "Input PHYS mark (old " << YELLOW << stud.exams[3] << DEFAULT_COLOR << "):\n";
                    input(stud.exams[3], 0, 10);

                    cout << "Input OAIP mark (old " << YELLOW << stud.exams[4] << DEFAULT_COLOR << "):\n";
                    input(stud.exams[4], 0, 10);

                    stud.update();
                    break;
                }
            }
            globals::db_students.save();
            cout << "Done!\n";
            system("pause");
        }
    }
}

void students::delete_select()
{
    while(true)
    {
        system("cls");
        show();
        int idx;
        cout << "Choose student to " << RED << "DELETE" << DEFAULT_COLOR << endl;
        cout << "0 - BACK\n";
        input(idx, 1, globals::db_students.students.size(), {0});
        if (idx == 0)
            return;
        cout << "Do you really want to " << RED << "DELETE " << DEFAULT_COLOR << globals::db_students.students[idx - 1].name << " [y/n]\n";
        bool b;
        input(b);
        if (b)
            globals::db_students.deleteStudent(idx - 1);
        cout << "Done!\n";
        system("pause");
    }
}

void students::show(vector<Student> &students)
{
    showTop();

    int idx=1;
    bool is_back = false;
    for(Student &stud : students)
    {
        if(idx % 2==0)
        {
            cout << BACKGROUND_GREY;
            is_back = true;
        }
        else
        {
            cout << DEFAULT_BACKGROUND_COLOR;
            is_back = false;
        }

        cout << '|' << setw(width::id) << centerString(idx < 10 ? ("0" + to_string(idx)) : to_string(idx), width::id, ' ')
             << setw(1) << '|';
        cout << setw(width::name) << left << stud.name << setw(1) << '|';
        cout << setw(width::number) << centerString(stud.number, width::number, ' ') << setw(1) << '|';
        cout << right;
        for(int i = 0; i < 5; i++)
        {
            bool b = stud.credits[i];
            if(is_back)
                cout << BACKGROUND_GREY;
            int curr_w = width::credits[i];
            if(i == 4)
                curr_w--;
            if(b)
            {
                cout << GREEN;
                cout << setw(curr_w) << 'P';
            }
            else
            {

                cout << RED;
                cout << setw(curr_w) << 'F';
            }
            if(i != 4)
                cout << ' ';
            cout << DEFAULT_COLOR;
        }
        if(is_back)
            cout << BACKGROUND_GREY;
        cout << " |";
        cout << DEFAULT_COLOR;
        for(int i = 0; i < 5; i++)
        {
            int x = stud.exams[i];
            if(is_back)
                cout << BACKGROUND_GREY;
            int curr_w = width::exams[i];
            if(i == 4)
                curr_w--;

            if(x > 4)
            {
                cout << GREEN;
            }
            else if(x == 4)
            {
                cout << YELLOW;
            }
            else
            {
                cout << RED;
            }

            cout << setw(curr_w) << x;

            if(i != 4)
                cout << ' ';
            cout << DEFAULT_COLOR;
        }
        if(is_back)
            cout << BACKGROUND_GREY;
        cout << " |";
        cout << fixed <<setw(width::average_mark) << setprecision(1) << stud.average_mark << setw(1) << "|";
        if(stud.debts == 0)
            cout << GREEN;
        cout <<setw(width::debts) << stud.debts;
        cout << WHITE <<'|';
        cout << DEFAULT_COLOR;
        cout << endl;
        idx++;
    }
    cout.fill('=');
    cout << setw( width::sumStud() + 8) << '=' << endl;
    cout.fill(' ');
}

void students::showTop()
{
    cout.fill('=');
    cout << setw( width::sumStud() + 8) << '=' << endl;
    cout.fill(' ');

    //! INAD:IKG:LANG:HIST:POLIT ,  MATH:OOP:TRPO:PHYS:OAIP

    cout << right <<'|' <<setw(width::id + 1) << '|' << setw(width::name + 1) << '|' << setw(width::number + 1) << '|'
         << setw(width::sumCredits()) << centerString("Credits", width::sumCredits(), ' ') << '|'
         << setw(width::sumExams()) << centerString("Exams", width::sumExams(), ' ') << '|'
         << setw(width::average_mark + 1) << '|' << setw(width::debts +1 ) << '|' << endl;

    cout << '|' << setw(width::id) << centerString("ID", width::id, ' ') << setw(1) << '|';
    cout << setw(width::name) << centerString("Name", width::name, ' ') << setw(1) << '|';
    cout << setw(width::number) << centerString("Group#", width::number, ' ') << setw(1) << '|';

    cout << setw(width::credits[0]) << "INAD" << setw(1) << ':';
    cout << setw(width::credits[1]) << "IKG" << setw(1) << ':';
    cout << setw(width::credits[2]) << "LANG" << setw(1) << ':';
    cout << setw(width::credits[3]) << "HIST" << setw(1) << ':';
    cout << left << setw(width::credits[4]) << "POLIT" << setw(1) << '|';

    cout << right << setw(width::exams[0]) << "MATH" << setw(1) << ':';
    cout << setw(width::exams[1]) << "OOP" << setw(1) << ':';
    cout << setw(width::exams[2]) << "TRPO" << setw(1) << ':';
    cout << setw(width::exams[3]) << "PHYS" << setw(1) << ':';
    cout << left << setw(width::exams[4]) << "OAIP" << setw(1) << '|' << right;

    cout << setw(width::average_mark) << centerString("Avg", width::average_mark, ' ') << setw(1) << '|';
    cout << setw(width::debts) << centerString("Debts", width::debts, ' ') << setw(1) << '|' << endl;

    cout.fill('=');
    cout << setw(width::sumStud() + 8) << '=' << endl;
    cout.fill(' ');
}

void students::sort_select()
{
    system("cls");
    cout << "Choose sort field:\n";
    cout << "1 - Name\n2 - Group\n3 - Average mark\n4 - Debts\n0 - Back\n";

    char choice;
    while (true)
    {
        choice = getch();
        choice -= '0';
        if (choice == 0)
        {
            return;

        }
        if (choice <= 4 && choice > 0)
        {
            break;
        }
    }

    vector<Student> v = globals::db_students.students;

    switch (choice)
    {
        case 1:
            sort(v.begin(), v.end(), [](Student& a, Student& b) ->bool {return a.name < b.name;});
            break;
        case 2:
            sort(v.begin(), v.end(), [](Student& a, Student& b) ->bool {return a.number < b.number;});
            break;
        case 3:
            sort(v.begin(), v.end(), [](Student& a, Student& b) ->bool {return a.average_mark > b.average_mark;});
            break;
        case 4:
            sort(v.begin(), v.end(), [](Student& a, Student& b) ->bool {return a.debts < b.debts;});
            break;
    }
    system("cls");
    show(v);
    system("pause");

}

void students::individualTask_select()
{
    vector<Student> v = globals::db_students.students;
    sort(v.begin(), v.end(), [](Student& a, Student& b) ->bool {return a.debts > b.debts;});
    vector<Student> gr;
    string group;
    double sum = 0;
    while(true)
    {
        system("cls");
        show(v);
        cout << "Input group number: ";
        group = inputNumber();

        for (Student &stud: v)
        {
            if (stud.number == group)
            {
                gr.push_back(stud);
                sum += stud.average_mark;
            }
        }

        if (gr.empty())
        {
            cout << "Group does not exist\n";
            system("pause");
        }
        else
            break;
    }
    system("cls");
    show(gr);
    cout << "Group " << group << " average mark: " << sum / gr.size() << endl;
    system("pause");
}

void students::search_select()
{
    while(true)
    {
        system("cls");
        cout << "Choose search field:\n";
        cout << "1 - Name\n2 - Group\n3 - Average mark\n4 - Debts\n0 - Back\n";

        char choice;
        while (true)
        {
            choice = getch();
            choice -= '0';
            if (choice == 0)
            {
                return;

            }
            if (choice <= 4 && choice > 0)
            {
                break;
            }
        }
        string s;
        double a, b;
        vector<Student> v;
        switch (choice)
        {
            case 1:
                cout << "Input name: ";
                if(cin.peek()=='\n')
                    cin.get();
                getline(cin, s);
                for (Student &stud: globals::db_students.students)
                {
                    if (to_upper(stud.name).find(to_upper(s))!=-1)
                        v.push_back(stud);
                }
                break;
            case 2:
                cout << "Input group: ";
                s = inputNumber();
                for (Student &stud: globals::db_students.students)
                {
                    if (stud.number == s)
                        v.push_back(stud);
                }
                break;
            case 3:
                cout << "Input min average mark\n";
                input(a, 0.0, 10.0);
                cout << "Input max average mark\n";
                input(b, a, 10.0);
                for (Student &stud: globals::db_students.students)
                {
                    if (stud.average_mark >= a && stud.average_mark <= b)
                        v.push_back(stud);
                }
                break;
            case 4:
                cout << "Input debts amount: ";
                input(a, 0, 10);

                for (Student &stud: globals::db_students.students)
                {
                    if (stud.debts == a)
                        v.push_back(stud);
                }
                break;
        }

        system("cls");
        if (v.size() == 0)
            cout << "There is nothing to show\n";
        else
            show(v);
        system("pause");
    }
}


#pragma endregion

/////MySpace.h

#pragma once
#include <iostream>
#include <unistd.h>
#include <vector>

#define RED "\033[31;1m"
#define GREEN "\033[32m"
#define WHITE "\033[37m"
#define YELLOW "\033[33m"
#define BLUE "\033[34;1m"
#define CYAN "\033[36;1m"
#define DEFAULT_COLOR "\033[m"
#define PINK "\033[35;1m"
#define BACKGROUND_GREY "\033[48;5;235m"
#define DEFAULT_BACKGROUND_COLOR "\033[40m"

#define CLEAR_LINE() (cout<<"\033[2K")
#define CLEAR_TO_END() (cout<<"\033[0J")
#define TO_COLUMN(num) (cout<<"\033["+to_string(num)+"G")
#define TO_POSITION(row, column) (cout<<"\033[" + to_string(row) + ";" + to_string(column) +"H")
#define CLEAR_LINE_TO_END() (cout<<"\033[0K")
#define UP_LINE() (cout << "\033[1A")
#define UP_LINES(x) (cout << "\033[" + to_string(x) + "F")
#define DOWN_LINES(x) (cout << "\033[" + to_string(x) + "E")
#define CURSOR_FORWARD (cout << "\033[1C")
#define CURSOR_BACK (cout << "\033[1D")
using namespace std;
template <typename T>
void input(T& a)
{
    while (true)
    {
        std::cin >> a;
        if (std::cin.fail() || (std::cin.peek() != '\n' && std::cin.peek() != ' ' && std::cin.peek() != '\t'))
        {
            std::cin.clear();
            std::cin.ignore(10000, '\n');
            cout << "Incorrect input"<<"\a\n";
            sleep(1);
            CLEAR_LINE();
            UP_LINE();
            CLEAR_LINE();
            UP_LINE();
            CLEAR_LINE();
        }
        else
        {
            std::cin.ignore(10000, '\n');
            return;
        }
    }
}//обертка для пользовательского ввода
void input(int& x, int a, int b);
void input(int& x, int a, int b, vector<int> additionalValues);
void input(double& x, double a, double b);
void input(bool& b);
std::string centerString(const std::string& s, int width, char fill_with);//центрирует строку, ограничивает пробелами
bool isFileEmpty(std::ifstream& file);//проверка пуст ли файл
string to_upper(string s);//строку в верхний регистр

/////MySpace.cpp

#include"MySpace.h"
#include <cstdlib>
#include <fstream>


using namespace std;

void input(int& x, int a, int b)
{
    while (true)
    {
        input(x);
        if (x < a || x > b)
        {
            cout << "Incorrect input [ " + to_string(a) + ", " + to_string(b) + " ]\n"<<"\a";
            cin.ignore(1000, '\n');
            sleep(1);
            CLEAR_LINE();
            UP_LINE();
            CLEAR_LINE();
            UP_LINE();
            CLEAR_LINE();
        }
        else
        {
            return;
        }
    }
}
void input(double& x, double a, double b)
{
    while (true)
    {
        input(x);
        if (x < a || x > b)
        {
            cout << "Incorrect input [ " + to_string(a) + ", " + to_string(b) + " ]\n"<<"\a";
            cin.ignore(1000, '\n');
            sleep(1);
            CLEAR_LINE();
            UP_LINE();
            CLEAR_LINE();
            UP_LINE();
            CLEAR_LINE();
        }
        else
        {
            return;
        }
    }
}
void input(bool& b)
{
    char c;
    while (true)
    {
        input(c);
        if (c != 'y' && c != 'n')
        {
            cout << "Incorrect input [ y / n ]\n"<<"\a";
            sleep(1);
            CLEAR_LINE();
            UP_LINE();
            CLEAR_LINE();
            UP_LINE();
            CLEAR_LINE();
        }
        else
        {
            b = c == 'y';
            return;
        }
    }
}

string centerString(const string &s, int width, char fill_with)
{
    string ret_str;
    int x = (width - s.length())/2;
    for (int i = 0; i < x; i++)
    {
        ret_str += fill_with;
    }
    ret_str += s;
    for (int i = ret_str.length() ; i < width; i++)
    {
        ret_str += fill_with;
    }
    return ret_str;
}

void input(int &x, int a, int b, vector<int> additionalValues)
{
    while (true)
    {
        input(x);
        if ((x < a || x > b) && (std::find(additionalValues.begin(), additionalValues.end(), x) == additionalValues.end()))
        {
            cout << "Incorrect input [ " + to_string(a) + ", " + to_string(b) + " ]\n"<<"\a";
            sleep(1);
            CLEAR_LINE();
            UP_LINE();
            CLEAR_LINE();
            UP_LINE();
            CLEAR_LINE();
        }
        else
            return;
    }
}

bool isFileEmpty(ifstream &file)
{
    return file.peek() == std::ifstream::traits_type::eof();
}

string to_upper(string s)
{
    for(char &c : s)
    {
        c = toupper(c);
    }
    return s;
}

/////Student.h

#pragma once

#include <string>
#include <fstream>
#include <iostream>
using namespace std;

class Student
{
public:
    Student(string name, string number, bool credits[5], int exams[5]);
    Student(){};
    string name;//фио
    bool credits[5];//зачеты
    int exams[5];//оценуи экзаменов
    string number;//номер группы
    int debts;//задолженности
    double average_mark;//средний балл

    void update();//обновить информацию о студенте (посчитать средний балл и задолженности)
    friend std::istream &operator >> (std::istream &is, Student &f);
    friend std::ostream& operator << (std::ostream &os, Student& f);
};

/////Student.cpp

#include "Student.h"

using namespace std;

string replaceChars(string s, char a, char b)
{
    for(char & i : s)
    {
        if(i == a)
            i = b;
    }
    return s;
}

Student::Student(string name, string number, bool credits[5], int exams[5])
{
    this->name = name;
    this->number = number;
    for(int i = 0; i < 5; i++)
    {
        this->credits[i] = credits[i];
        this->exams[i] = exams[i];
    }

    update();
}

std::istream &operator>>(istream &is, Student &f)
{
    if(typeid(is) == typeid(ifstream))
    {
        string name;
        is >> name;
        f.name = replaceChars(name, '_', ' ');
        is >> f.number;
        for(bool &b : f.credits)
            is >> b;
        for(int &i : f.exams)
            is >> i;
    }
    f.update();
    return is;
}

std::ostream &operator<<(ostream &os, Student &f)
{
    if(typeid(os) == typeid(ofstream))
    {
        string name;
        os << endl;
        name = replaceChars(f.name, ' ', '_');
        os << name <<' ';
        os << f.number <<' ';
        for(bool i : f.credits)
            os << i << ' ';
        for(int i = 0; i < 5; i++)
        {
            os << f.exams[i];
            if(i != 4)
                os << ' ';
        }
    }
    f.update();
    return os;
}

void Student::update()
{
    average_mark = 0;
    debts = 0;
    for (int i : exams)
    {
        average_mark += i;
        if(i < 4)
            debts++;
    }
    average_mark /= 5;

    for(bool b : credits)
    {
        if(!b)
            debts++;
    }

}

